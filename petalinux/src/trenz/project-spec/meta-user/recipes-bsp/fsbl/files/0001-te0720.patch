From cc85db54d26ffb82d1ee5154a97cea93f429deb4 Mon Sep 17 00:00:00 2001
From: John <j.hartfiel@trenz-electronic.de>
Date: Fri, 12 Feb 2021 20:02:08 +0100
Subject: [PATCH] te0720

---
 lib/sw_apps/zynq_fsbl/src/fsbl_hooks.c        |  15 +-
 lib/sw_apps/zynq_fsbl/src/fsbl_hooks.h        |   3 +
 lib/sw_apps/zynq_fsbl/src/main.c              |   9 +-
 lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks.c     | 352 ++++++++++++++++++
 lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks.h     |  47 +++
 .../zynq_fsbl/src/te_fsbl_hooks_te0720.c      | 349 +++++++++++++++++
 .../zynq_fsbl/src/te_fsbl_hooks_te0720.h      |  49 +++
 7 files changed, 821 insertions(+), 3 deletions(-)
 create mode 100644 lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks.c
 create mode 100644 lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks.h
 create mode 100644 lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks_te0720.c
 create mode 100644 lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks_te0720.h

diff --git a/lib/sw_apps/zynq_fsbl/src/fsbl_hooks.c b/lib/sw_apps/zynq_fsbl/src/fsbl_hooks.c
index c1014e53c9..6f24826dfe 100644
--- a/lib/sw_apps/zynq_fsbl/src/fsbl_hooks.c
+++ b/lib/sw_apps/zynq_fsbl/src/fsbl_hooks.c
@@ -58,6 +58,10 @@ u32 FsblHookBeforeBitstreamDload(void)
 	 * and returned
 	 */
 	fsbl_printf(DEBUG_INFO,"In FsblHookBeforeBitstreamDload function \r\n");
+  /* TE Mod:*/  
+  Status = TE_FsblHookBeforeBitstreamDload();
+/* TE Mod: finished*/                    
+
 
 	return (Status);
 }
@@ -85,7 +89,9 @@ u32 FsblHookAfterBitstreamDload(void)
 	 * Errors to be stored in the status variable and returned
 	 */
 	fsbl_printf(DEBUG_INFO, "In FsblHookAfterBitstreamDload function \r\n");
-
+/* TE Mod:*/  
+  Status = TE_FsblHookAfterBitstreamDload();
+/* TE Mod: finished*/ 
 	return (Status);
 }
 
@@ -112,7 +118,9 @@ u32 FsblHookBeforeHandoff(void)
 	 * Errors to be stored in the status variable and returned
 	 */
 	fsbl_printf(DEBUG_INFO,"In FsblHookBeforeHandoff function \r\n");
-
+/* TE Mod:*/  
+  Status = TE_FsblHookBeforeHandoff();
+/* TE Mod: finished*/
 	return (Status);
 }
 
@@ -132,6 +140,9 @@ void FsblHookFallback(void)
 	 * Errors to be stored in the status variable and returned
 	 */
 	fsbl_printf(DEBUG_INFO,"In FsblHookFallback function \r\n");
+/* TE Mod:*/  
+  TE_FsblHookFallback();
+/* TE Mod: finished*/
 	while(1);
 }
 
diff --git a/lib/sw_apps/zynq_fsbl/src/fsbl_hooks.h b/lib/sw_apps/zynq_fsbl/src/fsbl_hooks.h
index 9490084153..70fb4dda7d 100644
--- a/lib/sw_apps/zynq_fsbl/src/fsbl_hooks.h
+++ b/lib/sw_apps/zynq_fsbl/src/fsbl_hooks.h
@@ -32,6 +32,9 @@ extern "C" {
 
 /***************************** Include Files *********************************/
 #include "fsbl.h"
+/* TE Mod:*/
+#include "te_fsbl_hooks.h"
+/* TE Mod: finished*/                  
 
 
 /************************** Function Prototypes ******************************/
diff --git a/lib/sw_apps/zynq_fsbl/src/main.c b/lib/sw_apps/zynq_fsbl/src/main.c
index 62a5b4dd64..1bf4e3c0d3 100644
--- a/lib/sw_apps/zynq_fsbl/src/main.c
+++ b/lib/sw_apps/zynq_fsbl/src/main.c
@@ -270,7 +270,14 @@ int main(void)
 	fsbl_printf(DEBUG_GENERAL,"Release %d.%d	%s-%s\r\n",
 			SDK_RELEASE_YEAR, SDK_RELEASE_QUARTER,
 			__DATE__,__TIME__);
-
+// TE Mod :
+	xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+	xil_printf("Xilinx First Stage Boot Loader (TE modified) \n\r");
+	xil_printf("Release %d.%d	%s-%s\r\n",
+			SDK_RELEASE_YEAR, SDK_RELEASE_QUARTER,
+			__DATE__,__TIME__);
+      
+// TE Mod finished 
 #ifdef XPAR_PS7_DDR_0_S_AXI_BASEADDR
 
     /*
diff --git a/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks.c b/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks.c
new file mode 100644
index 0000000000..6f1d57154f
--- /dev/null
+++ b/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks.c
@@ -0,0 +1,352 @@
+/******************************************************************************
+*
+* 
+*
+******************************************************************************/
+
+/*****************************************************************************
+*
+* @file te_fsbl_hooks.c
+*
+*
+******************************************************************************/
+
+
+#include "fsbl.h"
+#include "xstatus.h"
+#include "te_fsbl_hooks.h"
+#include "xparameters.h"
+
+/************************** Variable Definitions *****************************/
+/*
+ * The following constants map to the XPAR parameters created in the
+ * xparameters.h file. They are only defined here such that a user can easily
+ * change all the needed parameters in one place.
+ */
+#define DCFG_DEVICE_ID		XPAR_XDCFG_0_DEVICE_ID
+
+/**
+ * @name Configuration Type1 packet headers masks
+ * @{
+ */
+#define XDC_TYPE_SHIFT			29
+#define XDC_REGISTER_SHIFT		13
+#define XDC_OP_SHIFT			27
+#define XDC_TYPE_1			1
+#define OPCODE_READ			1
+/* @} */
+
+/*
+ * Addresses of the Configuration Registers
+ */
+#define CRC		0	/* Status Register */
+#define FAR		1	/* Frame Address Register */
+#define FDRI		2	/* FDRI Register */
+#define FDRO		3	/* FDRO Register */
+#define CMD		4	/* Command Register */
+#define CTL0		5	/* Control Register 0 */
+#define MASK		6	/* MASK Register */
+#define STAT		7	/* Status Register */
+#define LOUT		8	/* LOUT Register */
+#define COR0		9	/* Configuration Options Register 0 */
+#define MFWR		10	/* MFWR Register */
+#define CBC		11	/* CBC Register */
+#define IDCODE		12	/* IDCODE Register */
+#define AXSS		13	/* AXSS Register */
+#define COR1		14	/* Configuration Options Register 1 */
+#define WBSTAR		15	/* Warm Boot Start Address Register */
+#define TIMER		16	/* Watchdog Timer Register */
+#define BOOTSTS		17	/* Boot History Status Register */
+#define CTL1		18	/* Control Register 1 */
+
+/************************** Function Prototypes ******************************/
+
+XDcfg DcfgInstance;		/* Device Configuration Interface Instance */
+/*****************************************************************************/
+
+/*
+ * read IDCODE over PCAP
+ *
+ */
+
+u32 XDcfg_RegAddr(u8 Register, u8 OpCode, u8 Size)
+{
+	/*
+	 * Type 1 Packet Header Format
+	 * The header section is always a 32-bit word.
+	 *
+	 * HeaderType | Opcode | Register Address | Reserved | Word Count
+	 * [31:29]	[28:27]		[26:13]	     [12:11]     [10:0]
+	 * --------------------------------------------------------------
+	 *   001 	  xx 	  RRRRRRRRRxxxxx	RR	xxxxxxxxxxx
+	 *
+	 * ´+¢R´+¢ means the bit is not used and reserved for future use.
+	 * The reserved bits should be written as 0s.
+	 *
+	 * Generating the Type 1 packet header which involves sifting of Type 1
+	 * Header Mask, Register value and the OpCode which is 01 in this case
+	 * as only read operation is to be carried out and then performing OR
+	 * operation with the Word Length.
+	 */
+	return ( ((XDC_TYPE_1 << XDC_TYPE_SHIFT) |
+		(Register << XDC_REGISTER_SHIFT) |
+		(OpCode << XDC_OP_SHIFT)) | Size);
+}
+
+
+int XDcfg_GetConfigReg(XDcfg *DcfgInstancePtr, u32 ConfigReg, u32 *RegData)
+{
+	u32 IntrStsReg;
+	u32 StatusReg;
+	unsigned int CmdIndex;
+	unsigned int CmdBuf[18];
+
+	/*
+	 * Clear the interrupt status bits
+	 */
+	XDcfg_IntrClear(DcfgInstancePtr, (XDCFG_IXR_PCFG_DONE_MASK |
+			XDCFG_IXR_D_P_DONE_MASK | XDCFG_IXR_DMA_DONE_MASK));
+
+	/* Check if DMA command queue is full */
+	StatusReg = XDcfg_ReadReg(DcfgInstancePtr->Config.BaseAddr,
+				XDCFG_STATUS_OFFSET);
+	if ((StatusReg & XDCFG_STATUS_DMA_CMD_Q_F_MASK) ==
+			XDCFG_STATUS_DMA_CMD_Q_F_MASK) {
+		return XST_FAILURE;
+	}
+
+	/*
+	 * Register Readback in non secure mode
+	 * Create the data to be written to read back the
+	 * Configuration Registers from PL Region.
+	 */
+	CmdIndex = 0;
+	CmdBuf[CmdIndex++] = 0xFFFFFFFF; 	/* Dummy Word */
+	CmdBuf[CmdIndex++] = 0xFFFFFFFF; 	/* Dummy Word */
+	CmdBuf[CmdIndex++] = 0xFFFFFFFF; 	/* Dummy Word */
+	CmdBuf[CmdIndex++] = 0xFFFFFFFF; 	/* Dummy Word */
+	CmdBuf[CmdIndex++] = 0xFFFFFFFF; 	/* Dummy Word */
+	CmdBuf[CmdIndex++] = 0xFFFFFFFF; 	/* Dummy Word */
+	CmdBuf[CmdIndex++] = 0xFFFFFFFF; 	/* Dummy Word */
+	CmdBuf[CmdIndex++] = 0xFFFFFFFF; 	/* Dummy Word */
+	CmdBuf[CmdIndex++] = 0x000000BB; 	/* Bus Width Sync Word */
+	CmdBuf[CmdIndex++] = 0x11220044; 	/* Bus Width Detect */
+	CmdBuf[CmdIndex++] = 0xFFFFFFFF; 	/* Dummy Word */
+	CmdBuf[CmdIndex++] = 0xAA995566; 	/* Sync Word */
+	CmdBuf[CmdIndex++] = 0x20000000; 	/* Type 1 NOOP Word 0 */
+	CmdBuf[CmdIndex++] = XDcfg_RegAddr(ConfigReg,OPCODE_READ,0x1);
+	CmdBuf[CmdIndex++] = 0x20000000; 	/* Type 1 NOOP Word 0 */
+	CmdBuf[CmdIndex++] = 0x20000000; 	/* Type 1 NOOP Word 0 */
+
+	XDcfg_Transfer(&DcfgInstance, (&CmdBuf[0]),
+			CmdIndex, RegData, 1, XDCFG_PCAP_READBACK);
+
+	/* Poll IXR_DMA_DONE */
+	IntrStsReg = XDcfg_IntrGetStatus(DcfgInstancePtr);
+	while ((IntrStsReg & XDCFG_IXR_DMA_DONE_MASK) !=
+			XDCFG_IXR_DMA_DONE_MASK) {
+		IntrStsReg = XDcfg_IntrGetStatus(DcfgInstancePtr);
+	}
+
+	/* Poll IXR_D_P_DONE */
+	while ((IntrStsReg & XDCFG_IXR_D_P_DONE_MASK) !=
+			XDCFG_IXR_D_P_DONE_MASK) {
+		IntrStsReg = XDcfg_IntrGetStatus(DcfgInstancePtr);
+	}
+
+	CmdIndex = 0;
+	CmdBuf[CmdIndex++] = 0x30008001;	/* Dummy Word */
+	CmdBuf[CmdIndex++] = 0x0000000D;	/* Bus Width Sync Word */
+	CmdBuf[CmdIndex++] = 0x20000000;	/* Bus Width Detect */
+	CmdBuf[CmdIndex++] = 0x20000000;	/* Dummy Word */
+	CmdBuf[CmdIndex++] = 0x20000000;	/* Bus Width Detect */
+	CmdBuf[CmdIndex++] = 0x20000000;	/* Dummy Word */
+
+	XDcfg_InitiateDma(DcfgInstancePtr, (u32)(&CmdBuf[0]),
+				XDCFG_DMA_INVALID_ADDRESS, CmdIndex, 0);
+
+	/* Poll IXR_DMA_DONE */
+	IntrStsReg = XDcfg_IntrGetStatus(DcfgInstancePtr);
+	while ((IntrStsReg & XDCFG_IXR_DMA_DONE_MASK) !=
+			XDCFG_IXR_DMA_DONE_MASK) {
+		IntrStsReg = XDcfg_IntrGetStatus(DcfgInstancePtr);
+	}
+
+	/* Poll IXR_D_P_DONE */
+	while ((IntrStsReg & XDCFG_IXR_D_P_DONE_MASK) !=
+			XDCFG_IXR_D_P_DONE_MASK) {
+		IntrStsReg = XDcfg_IntrGetStatus(DcfgInstancePtr);
+	}
+
+	return XST_SUCCESS;
+}
+
+u32 te_read_IDCODE(void)
+{
+  int Status;
+  unsigned int ValueBack;
+  unsigned int tmval;
+  XDcfg_Config *ConfigPtr;
+
+  /*
+   * Initialize the Device Configuration Interface driver.
+   */
+  ConfigPtr = XDcfg_LookupConfig(DCFG_DEVICE_ID);
+
+  /*
+   * This is where the virtual address would be used, this example
+   * uses physical address.
+   */
+  Status = XDcfg_CfgInitialize(&DcfgInstance, ConfigPtr,
+          ConfigPtr->BaseAddr);
+  if (Status != XST_SUCCESS) {
+    return XST_FAILURE;
+  }
+
+  /*
+   * Run the Self test.
+   */
+  Status = XDcfg_SelfTest(&DcfgInstance);
+  if (Status != XST_SUCCESS) {
+    return XST_FAILURE;
+  }
+
+
+  if (XDcfg_GetConfigReg(&DcfgInstance, IDCODE, (u32 *)&ValueBack) !=
+    XST_SUCCESS) {
+    return XST_FAILURE;
+  }
+  
+  xil_printf("\r\nDevice IDCODE: %x", ValueBack );
+  tmval=(ValueBack & 0x0001F000)>>12;
+  xil_printf("\r\nDevice Name: ");
+  if (tmval>>12==0x08) { xil_printf("7z014s");}
+  else if (tmval==0x02) { xil_printf("7z010");}
+  else if (tmval==0x1b) { xil_printf("7z015");}
+  else if (tmval==0x07) { xil_printf("7z020");}
+  else if (tmval==0x0c) { xil_printf("7z030");}
+  else if (tmval==0x11) { xil_printf("7z045");}
+  else {  xil_printf("(...)", tmval);}
+  xil_printf(" (%x)", tmval);
+  tmval=(ValueBack & 0xF0000000)>>28;
+  xil_printf("\r\nDevice Revision: %x ", tmval);
+  return XST_SUCCESS;
+}
+/******************************************************************************
+* This function is the hook which will be called  before the bitstream download.
+* The user can add all the customized code required to be executed before the
+* bitstream download to this routine.
+*
+* @param None
+*
+* @return
+*		- XST_SUCCESS to indicate success
+*		- XST_FAILURE.to indicate failure
+*
+****************************************************************************/
+u32 TE_FsblHookBeforeBitstreamDload(void)
+{
+	u32 Status;
+
+	Status = XST_SUCCESS;
+
+	/*
+	 * User logic to be added here. Errors to be stored in the status variable
+	 * and returned
+	 */
+	fsbl_printf(DEBUG_INFO,"In FsblHookBeforeBitstreamDload function \r\n");
+  
+  #if defined(ENABLE_TE_HOOKS_BD)
+    Status = TE_FsblHookBeforeBitstreamDload_Custom();
+  #endif  
+
+	return (Status);
+}
+
+/******************************************************************************
+* This function is the hook which will be called  after the bitstream download.
+* The user can add all the customized code required to be executed after the
+* bitstream download to this routine.
+*
+* @param None
+*
+* @return
+*		- XST_SUCCESS to indicate success
+*		- XST_FAILURE.to indicate failure
+*
+****************************************************************************/
+u32 TE_FsblHookAfterBitstreamDload(void)
+{
+	u32 Status;
+
+	Status = XST_SUCCESS;
+
+	/*
+	 * User logic to be added here.
+	 * Errors to be stored in the status variable and returned
+	 */
+	fsbl_printf(DEBUG_INFO, "In FsblHookAfterBitstreamDload function \r\n");
+  #if defined(ENABLE_TE_HOOKS_AD)
+    Status = TE_FsblHookAfterBitstreamDload_Custom();
+  #endif  
+
+	return (Status);
+}
+
+/******************************************************************************
+* This function is the hook which will be called  before the FSBL does a handoff
+* to the application. The user can add all the customized code required to be
+* executed before the handoff to this routine.
+*
+* @param None
+*
+* @return
+*		- XST_SUCCESS to indicate success
+*		- XST_FAILURE.to indicate failure
+*
+****************************************************************************/
+u32 TE_FsblHookBeforeHandoff(void)
+{
+	u32 Status;
+
+	Status = XST_SUCCESS;
+
+	/*
+	 * User logic to be added here.
+	 * Errors to be stored in the status variable and returned
+	 */
+	fsbl_printf(DEBUG_INFO,"In FsblHookBeforeHandoff function \r\n");
+
+  Status = te_read_IDCODE(); // general include to display Device ID of the zynq
+  #if defined(ENABLE_TE_HOOKS_BH)
+    Status = TE_FsblHookBeforeHandoff_Custom();
+  #endif  
+  
+	return (Status);
+}
+
+
+/******************************************************************************
+* This function is the hook which will be called in case FSBL fall back
+*
+* @param None
+*
+* @return None
+*
+****************************************************************************/
+void TE_FsblHookFallback(void)
+{
+	/*
+	 * User logic to be added here.
+	 * Errors to be stored in the status variable and returned
+	 */
+	fsbl_printf(DEBUG_INFO,"In FsblHookFallback function \r\n");
+  
+  #if defined(ENABLE_TE_HOOKS_FB)
+    TE_FsblHookFallback_Custom();
+  #endif  
+  
+	while(1);
+}
+
+
diff --git a/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks.h b/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks.h
new file mode 100644
index 0000000000..da9d224551
--- /dev/null
+++ b/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks.h
@@ -0,0 +1,47 @@
+/******************************************************************************
+*
+* 
+* 
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file te_fsbl_hooks.h
+*
+******************************************************************************/
+#ifndef TE_FSBL_HOOKS_H_
+#define TE_FSBL_HOOKS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+#include "fsbl.h"
+// rename and enable custom TE hooks
+#include "te_fsbl_hooks_te0720.h"
+// #define ENABLE_TE_HOOKS_BD //TE_FsblHookBeforeBitstreamDload
+// #define ENABLE_TE_HOOKS_AD //TE_FsblHookAfterBitstreamDload
+#define ENABLE_TE_HOOKS_BH //TE_FsblHookBeforeHandoff
+// #define ENABLE_TE_HOOKS_FB //TE_FsblHookFallback
+
+/************************** Function Prototypes ******************************/
+
+/* FSBL hook function which is called before bitstream download */
+u32 TE_FsblHookBeforeBitstreamDload(void);
+
+/* FSBL hook function which is called after bitstream download */
+u32 TE_FsblHookAfterBitstreamDload(void);
+
+/* FSBL hook function which is called before handoff to the application */
+u32 TE_FsblHookBeforeHandoff(void);
+
+/* FSBL hook function which is called in FSBL fallback */
+void TE_FsblHookFallback(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* end of protection macro */
diff --git a/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks_te0720.c b/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks_te0720.c
new file mode 100644
index 0000000000..62898cde04
--- /dev/null
+++ b/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks_te0720.c
@@ -0,0 +1,349 @@
+/******************************************************************************
+*
+* 
+* 
+*
+******************************************************************************/
+
+/*****************************************************************************
+*
+* @file te_fsbl_hooks.c
+* @author Antti Lukats
+* @copyright 2015 Trenz Electronic GmbH
+*
+*
+******************************************************************************/
+
+
+#include "fsbl.h"
+#include "xstatus.h"
+//rename to correct board name
+#include "te_fsbl_hooks_te0720.h"
+#include "xparameters.h"
+
+#include "xemacps.h"
+
+#include "xdevcfg.h"
+#include "xil_cache.h"
+
+/************************** Constant Definitions *****************************/
+#define TE0720
+
+// uncomment to add default video init into FSBL
+//#define TE_INIT_VIDEO
+/* 
+ * Settings to copy MAC address into OCM for u-boot usage in environment
+ */
+#define UBOOT_ENV_MAGIC 0xCAFEBABE
+#define UBOOT_ENV_MAGIC_ADDR 0xFFFFFC00
+#define UBOOT_ENV_ADDR 0xFFFFFC04
+
+/************************** Variable Definitions *****************************/
+
+/************************** Function Prototypes ******************************/
+
+/*****************************************************************************/
+
+
+#ifdef TE_INIT_VIDEO
+
+
+#endif
+
+
+#ifdef UBOOT_ENV_MAGIC
+
+/******************************************************************************
+* Convert a 4-bit value to hexadecimal representation (lowercase letters).
+*
+* @param x 4-bit value to be converted.
+* @return Hexadecimal representation.
+****************************************************************************/
+static char Uint4ToHex(const unsigned char x)
+{
+	if (x<10) {
+		return x + '0';
+	} else {
+		return x + ('a' - 10);
+	}
+}
+
+/******************************************************************************
+* Convert an octet to the hexadecimal representation (lowercase letters). A null byte is not appended.
+*
+* @param s Buffer to store hexadecimal representation. At least two bytes must be available.
+* @param x Octet to be converted.
+****************************************************************************/
+static void Uint8ToHex(char* s, const unsigned char x)
+{
+	s[0] = Uint4ToHex((x >> 4) & 0x0F);
+	s[1] = Uint4ToHex((x >> 0) & 0x0F);
+}
+
+/******************************************************************************
+* Convert MAC address to the environment string for the U-Boot to read the MAC address from.
+* Example: "ethaddr=00:0a:35:00:00:05\n"
+*
+* @param env Buffer to store the environment string. Must have at least 27 bytes available.
+* @param mac_addr MAC address, 6 bytes.
+****************************************************************************/
+static void MacToUbootEnvironment(char* env, const unsigned char* mac_addr)
+{
+	// end of "ethaddr=".
+	const int idx0 = 8;
+	const int N_MAC = 6;
+	int i;
+
+	strcpy(env, "ethaddr=");
+	for (i=0; i<N_MAC; ++i) {
+		const int idx = idx0 + 3*i;
+		Uint8ToHex(&env[idx], mac_addr[i]);
+		env[idx+2] = ':';
+	}
+	env[idx0 + 3 * N_MAC - 1] = '\n';
+	env[idx0 + 3 * N_MAC - 0] = 0;
+}
+
+#endif
+
+
+
+
+/******************************************************************************
+* This function is the hook which will be called  before the bitstream download.
+* The user can add all the customized code required to be executed before the
+* bitstream download to this routine.
+*
+* @param None
+*
+* @return
+*		- XST_SUCCESS to indicate success
+*		- XST_FAILURE.to indicate failure
+*
+****************************************************************************/
+u32 TE_FsblHookBeforeBitstreamDload_Custom(void)
+{
+	u32 Status;
+
+	Status = XST_SUCCESS;
+  
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+  xil_printf("TE0720 TE_FsblHookBeforeBitstreamDload_Custom\r\n"); 
+	/* Add the code here */
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+
+
+	return (Status);
+}
+
+/******************************************************************************
+* This function is the hook which will be called  after the bitstream download.
+* The user can add all the customized code required to be executed after the
+* bitstream download to this routine.
+*
+* @param None
+*
+* @return
+*		- XST_SUCCESS to indicate success
+*		- XST_FAILURE.to indicate failure
+*
+****************************************************************************/
+u32 TE_FsblHookAfterBitstreamDload_Custom(void)
+{
+	u32 Status;
+
+	Status = XST_SUCCESS;
+
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+  xil_printf("TE0720 TE_FsblHookAfterBitstreamDload_Custom\r\n"); 
+	/* Add the code here */
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+
+	return (Status);
+}
+
+/******************************************************************************
+* This function is the hook which will be called  before the FSBL does a handoff
+* to the application. The user can add all the customized code required to be
+* executed before the handoff to this routine.
+*
+* @param None
+*
+* @return
+*		- XST_SUCCESS to indicate success
+*		- XST_FAILURE.to indicate failure
+*
+****************************************************************************/
+u32 TE_FsblHookBeforeHandoff_Custom(void)
+{
+	u32 Status;
+
+	Status = XST_SUCCESS;
+
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+  xil_printf("TE0720 TE_FsblHookBeforeHandoff_Custom\r\n"); 
+	/* Add the code here */
+  
+  u32 device;
+
+	u16 rval16;
+	u8 speed_grade;
+	u8 pcb_rev;
+	unsigned char temp_grade;
+	unsigned char model1;
+	unsigned char model2;
+	unsigned char model3;
+
+	XEmacPs Emac;
+	XEmacPs_Config *Mac_Config;
+
+	unsigned char mac_addr[6];
+	int i = 0;
+
+
+  #ifdef TE_VIDEO_INIT
+
+  //	Status = adv7511_init(XPAR_XIICPS_0_DEVICE_ID, 0x00, ADV7511_ADDR);
+
+    Status = tpg_init(XPAR_V_TPG_0_DEVICE_ID);	
+    Status = vtc_init(XPAR_VTC_0_DEVICE_ID);
+    Status = vdma_init(XPAR_AXI_VDMA_0_DEVICE_ID);
+
+  #endif
+
+
+  #ifdef TE0720
+
+
+    Mac_Config = XEmacPs_LookupConfig(XPAR_PS7_ETHERNET_0_DEVICE_ID); if(Mac_Config == NULL) { return XST_FAILURE; }
+
+    Status = XEmacPs_CfgInitialize(&Emac, Mac_Config, Mac_Config->BaseAddress); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+      /*
+       * Read out MAC Address bytes
+     */
+    Status = XEmacPs_PhyRead(&Emac, 0x1A,  9, &rval16); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+    mac_addr[0] = (unsigned char)(rval16 >> 8);	
+          mac_addr[1] = (unsigned char)(rval16 & 0xFF);
+    Status = XEmacPs_PhyRead(&Emac, 0x1A,  10, &rval16); if(Status != XST_SUCCESS){	return XST_FAILURE; }
+    mac_addr[2] = (unsigned char)(rval16 >> 8);	
+          mac_addr[3] = (unsigned char)(rval16 & 0xFF);
+    Status = XEmacPs_PhyRead(&Emac, 0x1A,  11, &rval16); if(Status != XST_SUCCESS){	return XST_FAILURE; }
+    mac_addr[4] = (unsigned char)(rval16 >> 8);	
+          mac_addr[5] = (unsigned char)(rval16 & 0xFF);
+
+      /*
+       * Decode SoM model and version information!
+     */
+    // Read register 3
+    Status = XEmacPs_PhyRead(&Emac, 0x1A,  3, &rval16); if(Status != XST_SUCCESS){	return XST_FAILURE; }
+    pcb_rev = (rval16 >>10) & 0x7;
+
+    // Read register 4
+    Status = XEmacPs_PhyRead(&Emac, 0x1A,  4, &rval16); if(Status != XST_SUCCESS){	return XST_FAILURE; }
+
+
+    speed_grade = (rval16 >> 14) & 3;
+    /* 0=C, 1=E, 2=I, 3=A */
+    if ((rval16 & 0x3000)==0x0000) { temp_grade = 0x43; }
+    else if ((rval16 & 0x3000)==0x1000) { temp_grade = 0x45; }
+    else if ((rval16 & 0x3000)==0x2000) { temp_grade = 0x49; }
+    else if ((rval16 & 0x3000)==0x3000) { temp_grade = 0x41; }
+    else { temp_grade = 0x20; }
+    
+    if ((rval16 & 0x0F00)==0x000) { model1 = 0x20;model2 = 0x20;model3 = 0x46; } 
+    else if ((rval16 & 0x0F00)==0x100) { model1 = 0x20;model2 = 0x20;model3 = 0x52; }
+    else if ((rval16 & 0x0F00)==0x200) { model1 = 0x20;model2 = 0x4C;model3 = 0x46; }
+    else if ((rval16 & 0x0F00)==0x300) { model1 = 0x31;model2 = 0x34;model3 = 0x53; }
+    else { model1 = 0x31;model2 = 0x31;model3 = 0x31; }
+    
+    
+    xil_printf("\n\rSoM: TE0720-0%d-%d%c%c%c%c SC REV:%02x", pcb_rev, speed_grade, temp_grade, model1, model2, model3, rval16 & 0xFF);
+    xil_printf("\n\rMAC: ");
+
+    for(i = 0; i < 6; i++) {
+      xil_printf("%02x ", mac_addr[i]);
+    }
+    xil_printf("\n\r");
+  #endif
+
+    /*
+     * Write MAC Address to OCM memory for u-boot to import!
+     *
+     */
+
+    //strcpy(0xFFFFFC04, "ethaddr=00:0a:35:00:00:05\n" );
+  #ifdef UBOOT_ENV_MAGIC
+    Xil_Out32(UBOOT_ENV_MAGIC_ADDR, UBOOT_ENV_MAGIC); // Magic!
+    MacToUbootEnvironment((char*)UBOOT_ENV_ADDR, mac_addr);
+  #endif
+
+
+      /*
+       * Set MAC Address in PS7 IP Core registers
+     */
+    Status = XEmacPs_SetMacAddress(&Emac, mac_addr, 1); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+
+
+
+      /*
+       * Marvell PHY Config
+     */
+
+          /* Select Page 18 */
+    Status = XEmacPs_PhyWrite(&Emac, 0x00,  0x16, 0x0012); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+          /* Disable fiber/SGMII Autodetect */
+    Status = XEmacPs_PhyWrite(&Emac, 0x00,  0x14, 0x8210); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+
+          /* Select Page 3 */
+    Status = XEmacPs_PhyWrite(&Emac, 0x00,  0x16, 0x0003); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+          /* LED0: On link, Blink activity, LED1 Receive, LED2 Transmit */
+    Status = XEmacPs_PhyWrite(&Emac, 0x00,  16, 0x0501); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+          /* LED polarity positive, push-pull on=high */
+    Status = XEmacPs_PhyWrite(&Emac, 0x00,  17, 0x4415); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+
+
+          /* Select Page 0 */
+    Status = XEmacPs_PhyWrite(&Emac, 0x00,  0x16, 0x0000); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+    
+  #ifdef TE0720
+      /*
+       * SC LED remap
+       * Green = ETH LED 0, Red = MIO7, NOSEQ output = ETH LED0
+     */
+    Status = XEmacPs_PhyWrite(&Emac, 0x1A,  5, 0x0041); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+
+      /*
+       * Reset pulse to USB PHY
+     */
+    Status = XEmacPs_PhyWrite(&Emac, 0x1A,  7, 0x0010); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+    Status = XEmacPs_PhyWrite(&Emac, 0x1A,  7, 0x0000); if(Status != XST_SUCCESS){ return XST_FAILURE; }
+  #endif
+  
+  
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+  
+	return (Status);
+}
+
+
+/******************************************************************************
+* This function is the hook which will be called in case FSBL fall back
+*
+* @param None
+*
+* @return None
+*
+****************************************************************************/
+void TE_FsblHookFallback_Custom(void)
+{
+  
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+  xil_printf("TE0720 TE_FsblHookFallback_Custom\r\n"); 
+	/* Add the code here */
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+  
+  
+	//while(1);
+}
+
+
diff --git a/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks_te0720.h b/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks_te0720.h
new file mode 100644
index 0000000000..aa5aa3b398
--- /dev/null
+++ b/lib/sw_apps/zynq_fsbl/src/te_fsbl_hooks_te0720.h
@@ -0,0 +1,49 @@
+/******************************************************************************
+*
+* 
+* 
+*
+******************************************************************************/
+/*****************************************************************************/
+/**
+*
+* @file te_fsbl_hooks.h
+* @file te_fsbl_hooks.h
+* @author Antti Lukats
+* @copyright 2015 Trenz Electronic GmbH
+*
+*
+******************************************************************************/
+//rename to correct board name
+#ifndef TE_FSBL_HOOKS_CUSTOM_H_
+#define TE_FSBL_HOOKS_CUSTOM_H_
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+#include "fsbl.h"
+#include "xstatus.h"
+#include "fsbl_hooks.h"
+
+/************************** Function Prototypes ******************************/
+
+/* FSBL hook function which is called before bitstream download */
+u32 TE_FsblHookBeforeBitstreamDload_Custom(void);
+
+/* FSBL hook function which is called after bitstream download */
+u32 TE_FsblHookAfterBitstreamDload_Custom(void);
+
+/* FSBL hook function which is called before handoff to the application */
+u32 TE_FsblHookBeforeHandoff_Custom(void);
+
+/* FSBL hook function which is called in FSBL fallback */
+void TE_FsblHookFallback_Custom(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* end of protection macro */
-- 
2.30.0.windows.2

